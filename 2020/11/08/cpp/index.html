<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>cpp | 啵A&amp;博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="头文件：可以使用.h(c的头文件)或cpp标准头文件(,等)；cpp标准头文件都在std命名空间内    http:&#x2F;&#x2F;m.biancheng.net&#x2F;view&#x2F;2193.html命名空间：防止多人开发时命名冲突    语法：namespace name{….};    使用：1.每次前加作用域，例 name::变量，::域解析操作符          2.为后面单个申明，using  name:">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp">
<meta property="og:url" content="http://yoursite.com/2020/11/08/cpp/index.html">
<meta property="og:site_name" content="啵A&amp;博客">
<meta property="og:description" content="头文件：可以使用.h(c的头文件)或cpp标准头文件(,等)；cpp标准头文件都在std命名空间内    http:&#x2F;&#x2F;m.biancheng.net&#x2F;view&#x2F;2193.html命名空间：防止多人开发时命名冲突    语法：namespace name{….};    使用：1.每次前加作用域，例 name::变量，::域解析操作符          2.为后面单个申明，using  name:">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-08T08:51:25.000Z">
<meta property="article:modified_time" content="2020-11-08T08:52:49.873Z">
<meta property="article:author" content="啵A">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="啵A&amp;博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">啵A&amp;博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-cpp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/08/cpp/" class="article-date">
  <time datetime="2020-11-08T08:51:25.000Z" itemprop="datePublished">2020-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      cpp
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>头文件：可以使用.h(c的头文件)或cpp标准头文件(<cstdio>,<iostream>等)；cpp标准头文件都在std命名空间内<br>    <a target="_blank" rel="noopener" href="http://m.biancheng.net/view/2193.html">http://m.biancheng.net/view/2193.html</a><br>命名空间：防止多人开发时命名冲突<br>    语法：namespace name{….};<br>    使用：1.每次前加作用域，例 name::变量，::域解析操作符<br>          2.为后面单个申明，using  name::变量;<br>          3.所有申明，using namespace std(name)[大型项目局部申明]; std 标准命名空间<br>内存的分区模型：不同区域存放的数据，拥有不同的生命周期，编程更灵活<br>    代码区：存函数体的二进制代码，操作系统管理；共享，只读<br>    全局区：存全局变量，全局常量和静态变量及字符串常量；        默认值 0，下面两区默认 垃圾值<br>    前两区是生成EXE后，执行EXE前就划分的区域<br>    栈区：存参数值，局部变量和局部常量等，编译器自动分配释放；不要返回局部变量的地址（编译器只会保留一次其值）<br>    堆区：程序员分配释放，若不，程序结束后操作系统回收<br>    int * p = new int(10)/arr[3];p 在栈区， new的存储单元地址（p指向的数据）在堆区，delete p/[]arr 释放<br>指针：存放地址。指针也是地址，指针变量俗称指针，两者不是一个概念<br>    语法格式：int * p = &i;<br>    大小：一个字长<br>    指针运算符：变量前 * 转址，指针变量申明<br>            指针前 * 转值，解引用<br>            &amp; 取地址<br>    空指针：int * p = NULL；<br>        用来初始化。NULL编号为0的存储单元，0-255系统占用，不可 访问<br>    野指针：int * p = （int *）0x17379729；<br>        不能访问，避免<br>数组：存放同类型数据<br>    语法格式：int arr[2] = {1,2};不能缺省’长度’,元素默认值为0<br>        指针数组：int * arr[n];<br>            arr[n] = b[m];  一次存放一维数组<br>        数组指针：int (*arr)[n];<br>            arr = b[m][n];  一次存放二维数组<br>    数组名：数组首地址；指针常量，不可赋值<br>    访问：<br>        索引：a[n]<br>        指针：int * p = arr；*p++，p[n]<br>const：申明常量，防止修改<br>    语法格式：<br>        修饰常量：int * const p = &i;  –&gt;指针常量<br>            指向不可改，指向值可改  (*p = 3; 引用的实质)<br>        修饰指针：const int * p = &i; –&gt;常量指针<br>            指向可改，指向值不可改  (a = &b;)<br>        修饰指针和常量：const int * const p = &i;<br>            指向与指向值均不可改</p>
<p>引用：起别名，作为形参<br>    语法格式：数据类型 &amp;别名 = 原名; 不能空引用，必须初始化<br>    实质：int &amp;a = i &lt;==&gt; int * const a = &amp;i；a = 10 &lt;==&gt; *a = 10; 指针常量<br>    函数作左值，必须返回引用；返回静态变量引用，不能返回局部变量引用<br>    常量引用：const int &amp;a = 10;//编译器修改为 int temp = 10; const int &amp;a = temp; </p>
<p>指针与引用作为参数传递不产生副本；可以改变实参，也可用const修饰形参，防止误操作。</p>
<p>函数：代码封装，模块化<br>    参数：<br>        默认参数：放后边；申明或实现只能一个有<br>        占位参数：void func(int [ = 10]); 作用是函数重载<br>    重载：提高复用性<br>        1.条件：同一作用域；2.函数名相同；3.参数 类型/个数/顺序 不同。返回值不是条件<br>        2.坑：有默认参数时 防止二义性<br>    内联：替换作用，提高执行效率，耗费内存，适用于简单小函数<br>        inline:起建议作用，是否内联编译器决定。申明时写无效，实现前添加；成员函数类外实现前写，类内自带</p>
<p>宏定义：替换作用；定义的函数无数据类型限定</p>
<p>自定义数据类型：<br>    结构体：<br>        语法：struct 结构体名 {成员表} 变量名 = ｛.,.,.,.｝；<br>            1.struct<br>                ｛<br>                    成员表；</p>
<pre><code>            ｝变量名 [= &#123;.,.,.,.&#125;]；
        2.struct 结构体名
            ｛
                成员表；

            ｝变量名 [= &#123;.,.,.,.&#125;]；
        结构体名 变量名；
        3.typedef struct 结构体名
            ｛
                成员表；

            ｝类型别名；
        类型别名 变量名；
    访问：
        变量名.成员变量
        变量名-&gt;成员变量</code></pre>
<p>面向对象编程：提升复用性<br>    封装：类<br>        语法：class 类名｛访问权限：属性/行为 ｝;<br>        访问权限：<br>            1.public    公共权限 成员 类内外都可访问<br>            2.protected 保护权限 成员 类内可访问 继承可访问<br>            3.private   私有权限 成员 类内可访问 友元可访问<br>        成员变量：也叫属性<br>            静态成员变量：所有对象共享；不属于类对象上，类名也可访问<br>                类内申明（static 数据类型 变量名），类外初始化（数据类型 类名::变量名）<br>        成员函数：也叫行为/方法；不属于类对象上<br>            类内创建，默认带inline；类内申明，类外实现(推荐)，语法与上类似<br>            this指针：隐含于非静态成员函数内的特殊对象指针常量，指向被调的成员函数所属的对象<br>                1.形参与成员变量同名时，可用this区分；<br>                2.引用型函数，返回对象本身：return *this; 用于链式编程<br>            非静态成员函数：同类型对象共用的一块代码，通过特殊对象指针this区分是哪个对象调用<br>            静态成员函数：所有对象共享；只能访问静态成员变量；不能使用this指针；语法与上类似<br>            常成员函数：不可修改成员属性(mutable 属性 则可改)。本质就是const修饰了this<br>                语法：类型 函数名()const {…}; ==&gt; const 类名 * const this<br>        构造函数：系统自动调用，类实例化时完成对象初始化<br>            语法：类名(..){…}; 有参数可重载<br>            初始化列表：类名(..):属性(形参变量)，属性(形参变量)，…{}; 常属性只能用初始化列表<br>            调用：1.()法 C c(10)；2.显示法 C c=C(10)；3.隐式转换法 C c=10；C(10) 匿名对象 会内存泄漏<br>            坑：调用无参构造函数时不要加(),编译器会误以为是函数申明<br>        拷贝构造函数：拷贝对象<br>            语法：类名(c1){….}；<br>            浅拷贝：问题是属性有堆区内存时会被重复释放<br>            深拷贝：用于有堆区数据的对象拷贝；语法：类名(const 类名 &amp;p){a = p.a; b = new int(*p.b};<br>        析构函数：系统自动调用，对象销毁前完成对象清理工作；用于释放堆区开辟的数据，关闭文件等<br>            语法： ~类名(){…}; 没参数不可重载<br>        若不手动创建，编译器会提供4个函数，构造函数与析构函数的空实现及值拷贝的拷贝构造函数和=重载函数<br>        拓展：<br>            def <strong>init</strong>(self, m,…):<br>                self.m = m<br>                ….<br>            def <strong>del</strong>(self):<br>                ….<br>            obj = className(args)<br>            del obj<br>            self是类的实例，也是类方法与普通函数的区别<br>            cpp隐藏了类似self的this指针；<br>        对象：类的实例化；<br>            空对象占用1B，普通对象占用只是非静态成员变量的大小和,成员变量(非静态)与成员函数分开存储；<br>            空指针对象可访问其不带属性的行为，所以要判断，防止权限问题（鲁棒性考虑）<br>            常对象:实例化前加const修饰，只能调用常函数，不可修改其属性(mutable 属性 则可改)<br>        参数：调用成员函数的对象就是一个参数；对象作参数一般引用传递<br>        友元：可以访问私有权限<br>            类作友元：类1 在类2中申明前加friend，类1的对象可以访问类2私有成员<br>            成员函数作友元：类1的成员函数 在类2中申明前加friend，该成员函数可访类2私有属性<br>            全局函数作友元：全局函数 在类中申明前加friend，该函数可访问该类私有属性<br>        运算符重载：自定义数据类型运算；修改参数可以发生函数重载<br>            语法：类名 operator+(参数表){….}; +重载；()重载 也叫仿函数<br>            本质：P p3 = p1 + p2; 成员函数 p1.operator+(p2); 全局函数 operator+(p1, p2);<br>            注：内置数据类型不能改；不要滥用重载<br>            例：ostream &amp;operator&lt;&lt;(ostream &amp;cout,类名 &amp;p){cout &lt;&lt;”a=”&lt;&lt;p.a;return cout;};成员函数没法<br>    继承：派生类重复利用基类代码；既具有共性，又具有个性<br>        语法：class 子类名:继承方式 父类1[,继承方式 父类2,….]{….};<br>        继承方式：<br>            1.公有继承：基类私有成员不可访问，公有与保护权限不改变<br>            2.保护继承：基类私有成员不可访问，公有与保护权限变保护<br>            3.私有继承：基类私有成员不可访问，公有与保护权限变私有<br>        虚继承：解决菱形继承多份数据的问题<br>            语法：class 派生类:virtual 继承方式 虚基类{….};<br>            本质：派生类继承的是虚基类指针，虚基类指针通过虚基类列表中偏移量指向唯一数据<br>        同名成员访问：1.对象访问 2.类访问(静态)；对象成员符 . 类成员符 :: (作用域 类名::)<br>        子类对象：继承父类中所有非静态成员属性，占用空间为所有非静态成员变量与虚指针的大小和<br>        拓展：利用开发人员命令行查看对象模型 文件路径下&gt;cl /d1 reportSingleClassLayout类名 文件名<br>    多态：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护<br>        静态多态：函数重载和运算符重载,复用函数名；编译阶段确定函数地址，早绑定<br>        动态多态：派生类和虚函数实现运行时多态；运行阶段确定函数地址，晚绑定<br>            子类重写父类虚函数；父类指针或引用接收子类对象<br>        虚函数：virtual 类型 函数名(…){…};<br>            本质：创建虚函数指针，通过存放虚函数地址的虚函数表中指向唯一虚函数地址<br>        纯虚函数：virtual 类型 函数名(…) = 0;<br>            意义：通常虚函数的实现没有意义<br>        [纯]虚析构:若子类有属性在堆区，解决父类指针在释放时无法调用到子类的析构代码问题<br>            都需要有具体函数实现，纯虚析构在类外实现<br>        抽象类：有纯虚函数的类，无法实例化对象<br>            注：无法实例化对象；子类必须重写抽象类的纯虚函数，否则也就成了抽象类<br>        开发原则：对扩展进行开放，对修改进行关闭，多态的重要性<br>struct 默认权限public，class 默认权限private；两者都是自定义数据类型<br>    参与设计全世界第一套C++ 编译器cfront的Lippman在《深度探索C++内存模型》中指出：<br>一个常被程序员询问的问题是：什么时候一个人应该在C++程序中以struct替代class？如果是<br>1986年，我的答案豪不拖泥带水：“绝不！”……那么，让我重新问一次：“什么时候一个人<br>应该使用struct取代class”答案之一是：当它让一个人感觉比较好的时候。<br>你甚至可以主张说它的用途只是为了方便C程序员迁徙至C++ 部落。因为C++的class真的只是个<br>struct，只不过C++编译器会在编译期对它做一些“魔改”动作而已。早年，诸如游戏业的精灵<br>抽象、unix系的“一切皆文件”等设计思想，都是用C乃至汇编表现出来的。正是这些思想启发<br>并引导了后来的面向对象热潮。对C来说，struct可以放任何它支持的数据类型。包括函数指针<br>——后来C++所谓的虚函数表，很多编译器的实现，就是一个指向另一个全局结构体的指针，这<br>个全局结构体里面是一条一条的函数指针，指向对应类重载后的所谓“虚函数”。至于各种所<br>谓的成员函数，实际上就是些第一个参数是classXX类型的this指针的普通函数。换言之，<br>struct本身已经足以支持面向对象编程运行期需要的一切了；现在，我们只需要增加一些新的<br>语法约定，使得编译器可以帮助用户自动维护这些琐碎细节就行了——这正是 Bjarne<br>Stroustrup当年搞Cfront的设计思路：先把C++代码自动魔改到C，然后调用C编译器完成编译。<br>后期虽然有了直接支持c++的编译器（因为在cfront中加入异常支持失败），但编译器关于<br>struct的处理并没有本质的不同。于是，所谓class，其实就是加了某些外部支持的struct<br>——除了编译期可能会被编译器魔改的面目全非外，它和普通struct毫无差别。这个支持一<br>般来说应该是这样的（但并不禁止编译器厂商选择其他方案）：<br>    1、对普通成员函数，为它自动添加this参数，并在调用它时，自动把 obj.method() 转<br>换成method(obj)格式；并识别出函数中涉及的、没有显式使用this的成员变量、为它加上<br>this。除此之外，别的什么都不用做。<br>    2、对虚函数，需要为继承链上的每个类产生一个全局结构体，在这个结构体里按次序安<br>排指向该类所有虚函数的指针，这就是虚函数表；然后在类里添加一个指向属于自己的虚函数<br>表的指针。那么，当用户调用某个对象的第N个虚函数时，到虚函数表查找并获取第N个函数指<br>针指向的内容；然后类似调用普通成员函数一样，把 obj.method() 转换成 method(obj)格<br>式，多态就实现了。<br>    当然，除此之外，还要在编译时执行权限检查，避免非法访问类的protect/private成员<br>（struct默认权限是public，class是private）；以及另外一些琐碎工作。所以你看，c++的类<br>归根结底，它就是个C语言的struct。只是（相当于）在编译期做了些预处理而已——只要你在<br>里面声明了成员函数，就会自动触发预处理，从而实现“自动魔改你所定义的数据结构，使其支<br>持OO诸要素”功能。<br>那么，除了让C代码共用C++里面定义的struct这个特殊场景外（想了解这类能兼容C的数据类型，<br>可搜索 POD类型），你说还有什么理由禁止struct拥有成员函数呢？</p>
<p>文件操作：<fstream><br>    w：ofstream obj; obj.open(“path”,打开方式); obj &lt;&lt; “写入数据”; obj.close();<br>    r：ifstream obj; obj.open(“path”,打开方式); obj &gt;&gt; 接收变量; obj.close();<br>    rw：fstream obj; obj.open(“path”,打开方式); ….<br>    打开方式：1.ios::in；2.ios::out；3.ios::app。例：二进制写 ios::binary | ios::out</p>
<p>泛型编程：静态语言的动态化<br>    模板：通用模具，提高复用性；不可直接使用，只是框架<br>        函数模板：通用函数，其返回值类型与形参类型用虚拟的类型(T)代表<br>            语法：template &lt;typename T1, …&gt;；函数；T1通用类型<br>            调用：1.自动推倒类型(一致) 函数名(变量名，..); 2.显示指定类型 函数名&lt;类型&gt;(变量名，..);<br>            注：自动推到类型，不能隐式类型转换；显示指定类型与普通函数调用时可以隐式类型转换<br>            拓展：c是 静态、弱类型语言，自动推倒类型似 动态、强类型语言<br>        类模板：通用类，其成员类型为虚拟的类型(T1，T2，…)<br>            语法：template &lt;class T1[= int]，…&gt;；类；T1通用类型[可以默认]<br>            调用：类模板&lt;类型表&gt; 对象名(参数表)；只能是显示指定类型，后面容器会用<br>            注：子类继承类模板时要确定类型；成员函数类外实现时加上模板参数列表<br>            ps:分文件编写时，类模板写在.hpp文件中<br>STL：标准模板库；为了重复利用，建立了数据结构与算法的一套标准；<br>    六大组件：容器，算法，迭代器，仿函数，适配器(配接器)，空间配置器<br>    关系：容器与算法之间通过迭代器进行连接<br>    1.容器：vector、list、deque、set、map等；各自头文件<br>        序列式容器(强调值的排序，元素有固定位置)<br>        关联式容器(二叉树结构，元素间没有严格物理顺序)<br>        例：vector <int> v; v.push_back(10);<br>    2.算法：sort、random_shuffle、find、copy、for_each等；标准头文件<algorithm><br>        质变算法(拷贝、替换等，更改区间内元素的内容)<br>        非质变算法(查找、遍历等，不更改区间内元素的内容)<br>        例：sort(v.begin(), v.end(), greater<int>()); greater<int>()谓词<br>    3.迭代器：容器与算法之间的胶合剂，每个容器都有专属迭代器<br>        输入迭代器：只读，支持++、==、!=<br>        输出迭代器：只写，支持++<br>        向前迭代器：读写并向前推进，支持++、==、!=<br>        双向迭代器：读写并前后操作，支持++、–<br>        随机访问迭代器：读写可跳跃的随机访问，支持++、–、[n]、-n、&lt;、&gt;、&lt;=、&gt;=<br>        例：for(vector<int>::iterator it = v.begin; it != v.end(); it++) cout &lt;&lt; *it &lt;&lt; endl;<br>    4.仿函数：可作为算法的莫种策略；内建函数对象头文件<functional><br>        函数对象：函数调用操作符重载的类的对象；是一个类，不是函数；其使用重载()时行为类似函数，也叫仿函数<br>        谓词：返回值类型为bool型的仿函数；n元谓词：返回值n个<br>    5.适配器：修饰容器或仿函数或迭代器接口的东西<br>    6.空间配置器：负责空间的配置与管理</p>
<p>#include <ctime><br>//随机数种子<br>srand((unsigned int)time(NULL));<br>int random = rand()%41 + 60; //60-100</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/08/cpp/" data-id="ckh9e13db000ds78pbcudgtyq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/11/08/mongodb/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          mongodb
        
      </div>
    </a>
  
  
    <a href="/2020/11/08/python/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">python</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/08/mssql/">mssql</a>
          </li>
        
          <li>
            <a href="/2020/11/08/redis/">redis</a>
          </li>
        
          <li>
            <a href="/2020/11/08/mongodb/">mongodb</a>
          </li>
        
          <li>
            <a href="/2020/11/08/cpp/">cpp</a>
          </li>
        
          <li>
            <a href="/2020/11/08/python/">python</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 啵A<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>